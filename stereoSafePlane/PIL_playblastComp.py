# -*- coding: utf-8 -*-
__author__ = 'lvyuedong'

import os
import sys
import traceback
import math
import stat
import time
import glob
import optparse
import subprocess
import multiprocessing as mp
import commonFunc as cf
from PIL import Image, ImageChops, ImageMath

imgWidthHeight = (2048,858)
white = Image.new('F', imgWidthHeight, 255.0)

def createConstantImg(mode='F', color='white'):
    # return Image class
    global imgWidthHeight
    return Image.new(mode, imgWidthHeight, color)

def splitImageChannels(mode, img):
    r,g,b,a = None, None, None, None
    img.getim() # futile call, just prevent error before calling split method
    if img.mode=='RGBA':
        r,g,b,a = img.split()
    elif img.mode=='RGB':
        r,g,b = img.split()
    else:
        return [img]

    r = r.convert(mode)
    g = g.convert(mode)
    b = b.convert(mode)
    if a:
        a = a.convert(mode)
    return [r,g,b,a]

def compositeAlpha(img1, img2, bg=None):
    # merge img1 over img2 by using img1's alpha
    # if bg is valid, we merge img2 and bg firstly
    img2_ch = splitImageChannels('L', img2)
    if bg:
        bg_ch = splitImageChannels('L', bg)
        if img2_ch[3] and bg_ch[3]:
            alpha = ImageChops.add(img2_ch[3], bg_ch[3])
        img2 = Image.composite(img2, bg, img2_ch[3])
        img2.putalpha(alpha)
    img1_ch = splitImageChannels('L', img1)
    out = Image.composite(img1, img2, img1_ch[3])
    if img2_ch[3] and img1_ch[3]:
        alpha = ImageChops.add(img1_ch[3], img2_ch[3])
        out.putalpha(alpha)
    return out

def compositeAlphaRecursive(images):
    # images is a list of Image objects, the front image comes first, the rear image goes to end
    if len(images)<2:
        print 'compositeAlphaRecursive: need two images at least, only find one.'
        return None
    if len(images)==2:
        return compositeAlpha(images[0], images[1])
    else:
        comp = compositeAlphaRecursive(images[1:])
        return compositeAlpha(images[0], comp)

def chromeKeyBluescreen(r, g, b):
    # return an alpha image with mode 'F'
    # the r,g,b and white should be 'F' mode
    # we use 'F' mode in case of negative value
    global white
    return ImageMath.eval('r+g-b+d',r=r,g=g,b=b,d=white)

def compositeChromeKey(img1, img2, bg=None):
    # merge img1 over img2 by using a transparent mask, which generated by chrome key
    # if bg is valid, we merge img2 and bg firstly
    img2_ch = splitImageChannels('F', img2)
    if bg:
        # get chrome key of img2 to merge with bg
        bg_ch = splitImageChannels('F', bg)
        if img2_ch[3] and bg_ch[3]:
            alpha = ImageChops.add(img2_ch[3].convert('L'), bg_ch[3].convert('L'))
        img2_mask = chromeKeyBluescreen(img2_ch[0], img2_ch[1], img2_ch[2])
        img2 = Image.composite(img2, bg, img2_mask.convert('L'))    # Image.composite doesn't works with 'F' mode mask
        img2.putalpha(alpha)
    img1_ch = splitImageChannels('F', img1)
    img1_mask = chromeKeyBluescreen(img1_ch[0], img1_ch[1], img1_ch[2])
    out = Image.composite(img1, img2, img1_mask.convert('L'))
    if img2_ch[3] and img1_ch[3]:
        alpha = ImageChops.add(img1_ch[3].convert('L'), img2_ch[3].convert('L'))
        out.putalpha(alpha)
    return out

def compositeChromeKeyRecursive(images):
    # images is a list of Image objects, the front image comes first, the rear image goes to end
    if len(images)<2:
        print 'compositeChromeKeyRecursive: need two images at least, only find one.'
        return None
    if len(images)==2:
        return compositeChromeKey(images[0], images[1])
    else:
        comp = compositeChromeKeyRecursive(images[1:])
        return compositeChromeKey(images[0], comp)

def imageOpen(path):
    # we suggest the png format. PIL can handle png very fast
    return Image.open(cf.osPathConvert(path))

def imageSave(img, path):
    img.save(cf.osPathConvert(path))

def composite_single_thread(images, save_path, frame, ext, compositeMode):
    # the images and save_path parameters have the same definition with main()
    if isinstance(frame, int) or isinstance(frame, float):
        frame = format(int(frame), '04d')
    save_path += '.%V.'+ frame + '.' + ext
    # we composite layers from rear to front
    left = []
    right = []
    if 'near' in images.keys():
        left.append(imageOpen(images['near'][0].replace('####', frame)))
        right.append(imageOpen(images['near'][1].replace('####', frame)))
    if 'main' in images.keys():
        left.append(imageOpen(images['main'][0].replace('####', frame)))
        right.append(imageOpen(images['main'][1].replace('####', frame)))
    if 'far' in images.keys():
        left.append(imageOpen(images['far'][0].replace('####', frame)))
        right.append(imageOpen(images['far'][1].replace('####', frame)))
    # left
    if compositeMode=='chromeKey':
        out = compositeChromeKeyRecursive(left)
    else:
        out = compositeAlphaRecursive(left)
    imageSave(out, save_path.replace('%V', 'left'))
    # right
    if compositeMode=='chromeKey':
        out = compositeChromeKeyRecursive(right)
    else:
        out = compositeAlphaRecursive(right)
    imageSave(out, save_path.replace('%V', 'right'))

def composite_threading(images, save_path, frame, ext, compositeMode, output):
    try:
        composite_single_thread(images, save_path, frame, ext, compositeMode)
    except:
        output.put( {save_path:False} )
    output.put( {save_path:True} )

def multiProcess(param=[]):
    '''
        param is a list of func and parameters
        param = [ func, [args1], [args2], ... ]
    '''
    output = mp.Queue()
    processes = [ mp.Process( target=param[0], args=tuple( param[n+1]+[output] ) ) for n in range(len(param)-1) ]
    for p in processes:
        p.start()
    for p in processes:
        p.join()
    results = [output.get() for p in processes]
    return results

def grabImages(path, ext):
    # get the images from path automatically
    path = cf.osPathConvert(path)
    img_near = sorted(glob.glob(os.path.join(path, '[a-z][0-9]????.flo.stereo.v[0-9]??.near.left.[0-9]???.'+ext)))
    img_main = sorted(glob.glob(os.path.join(path, '[a-z][0-9]????.flo.stereo.v[0-9]??.main.left.[0-9]???.'+ext)))
    img_far = sorted(glob.glob(os.path.join(path, '[a-z][0-9]????.flo.stereo.v[0-9]??.far.left.[0-9]???.'+ext)))
    if not img_main:
        print 'Failed to find images in the path '+path
        return {}
    # get cut in and cut out
    cut_in = int(img_main[0].split('.')[-2])
    cut_out = int(img_main[-1].split('.')[-2])

    images = {}
    for (i,j) in [('near',img_near), ('main',img_main), ('far',img_far)]:
        if not j:
            continue
        l = j[0].replace('.'+format(cut_in, '04d')+'.'+ext, '.####.'+ext)
        r = j[0].replace('.left.'+format(cut_in, '04d')+'.'+ext, '.right.####.'+ext)
        images.update( {i:[l,r]} )
    save_path = img_main[0].replace('.main.left.'+format(cut_in, '04d')+'.'+ext, '')
    return {'images':images, 'cut_in':cut_in, 'cut_out':cut_out, 'save_path':save_path}

def createShellScript(image_path, compositeMode='chromeKey'):
    import maya.mel as mel
    env = mel.eval('getenv MAYA_LOCATION')
    if not env:
        print 'Failed to locate MAYA_LOCATION'
        return
    python = cf.osPathConvert(os.path.join(env, 'bin/mayapy'))

    image_path = cf.osPathConvert(image_path)
    if image_path.endswith('/'):
        image_path = image_path[:-1]

    batch = os.path.join(mel.eval('getenv TMPDIR'), image_path.split('/')[-1])
    if os.name == 'nt':
        batch += '.bat'
    else:
        batch += '.sh'

    fileid = open(batch, 'w')
    if os.name != 'nt':
        fileid.write('#!/bin/bash\n')

    cmd = '"'+python+'" "'+__file__+'" -p "'+image_path+'" -m 0 -c '+compositeMode
    fileid.write(cmd)
    fileid.close()

    try:
        st = os.stat(batch)
        os.chmod(batch, st.st_mode | stat.S_IEXEC | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except:
        print traceback.format_exc()
    return batch

def main(images, save_path='', cut_in=0, cut_out=0, ext='png', numOfCores=0, mayaMode=True, \
            compositeMode='chromeKey'):
    '''
    1. the images should be formated as {'main':[left,right], 'far':[left,right], 'near':[left,right]},
       while the left is the path like /path/i60050.flo.stereo.v001.far.left.####.png
    2. the save_path should be formated as the scene name as /path/i60050.flo.stereo.v001
    3. if you run this python script in ternimal, turn off mayaMode
    4. use chromeKey compositeMode for Maya default playblasting,
       use alpha compositeMode for Maya Viewport 2.0 playblasting.
       Because default playblasting doesn't generate alpha channel, we have to use chrome key.

    Note, maya doesn't supports to run python multi-process (amazing),
    so we try to write a shell script and execute it externally.
    But up to now (Nov 2017), Maya 2017 update 4 can not execute shell script which contain python command,
    I believe this is a bug, so we have to use the MAYA_LOCATION/bin/mayapy instead of the system python.

    TO-DO:
    test future release of Maya, if it support python multi-process
    '''
    if isinstance(images, str) and os.path.isdir(images):
        tmp = grabImages(images, ext)
        images = tmp['images']
        save_path = tmp['save_path']
        cut_in = tmp['cut_in']
        cut_out = tmp['cut_out']
    else:
        print 'Please input a valid images dict or path to the images'

    total_frames = cut_out - cut_in + 1
    if total_frames<=0:
        print 'Please input a valid frame range'
        return

    frames = range(int(cut_in), int(cut_out+1))

    print 'Total amount of frames is '+str(total_frames)
    percent = 0
    start_time = time.time()

    if mayaMode:
        print 'mayaMode is True, use shell script'
        script = createShellScript( os.path.dirname(save_path), compositeMode=compositeMode )
        print 'Shell script: '+script
        #os.system(script)
        subprocess.call(script, stderr=subprocess.PIPE)
        os.remove(script)
        return
            
    if numOfCores==0:
        numOfCores = mp.cpu_count()

    for frames_grp in [ frames[i:i+numOfCores] for i in range(0, len(frames), numOfCores) ]:
        numOfProcess = 0
        param = [composite_threading]
        for f in frames_grp:
            param.append( [ images, save_path, f, ext, compositeMode] )
            numOfProcess = numOfProcess + 1
        # multi process composite
        result = multiProcess( param )
        # check result
        for r in result:
            try:
                if not r.values()[0]:
                    print 'Failed to composite: ' + r.keys()[0]
                    error.append( r.keys()[0] )
            except:
                print traceback.format_exc()
        percent += len(frames_grp)
        progress = float(percent)/float(total_frames)
        # print progress
        print 'Completed: '+str(percent)+' in '+str(total_frames)+', '+format( progress*100.0, '.2f' )+'%'
    # print time
    end_time = time.time()
    time_elapsed = end_time - start_time
    print 'Time elapsed: '+cf.time2Durations(time_elapsed)

#images = {'far': [u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.far.left.####.png', u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.far.right.####.png'], 'near': [u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.near.left.####.png', u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.near.right.####.png'], 'main': [u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.main.left.####.png', u'/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001.main.right.####.png']}
#save_path = '/mnt/public/home/lvyuedong/maya/projects/default/scenes/images/i60050.flo.stereo.v001.ma/i60050.flo.stereo.v001'

if __name__ == '__main__':
    ''' === Args Parsing === '''
    parser = optparse.OptionParser()
    parser.add_option('-p', '--path', dest='path', help='path to the images', default='')
    parser.add_option('-m', '--maya', dest='maya', help='maya mode', default='1')
    parser.add_option('-c', '--compositeMode', dest='compositeMode', help='composite mode', default='chromeKey')

    (options, args) = parser.parse_args()
    print options.path, options.maya, options.compositeMode
    if options.maya=='0' or options.maya=='False' or options.maya=='false':
        options.maya = False
    else:
        options.maya = True
    main( images=options.path, mayaMode=options.maya, compositeMode=options.compositeMode )

    sys.exit(0)