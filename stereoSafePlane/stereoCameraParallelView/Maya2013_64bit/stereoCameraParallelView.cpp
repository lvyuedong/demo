//-
// ==========================================================================
// Copyright (C) 1995 - 2006 Autodesk, Inc. and/or its licensors.  All
// rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its
// licensors, which is protected by U.S. and Canadian federal copyright
// law and by international treaties.
//
// The Data is provided for use exclusively by You. You have the right
// to use, modify, and incorporate this Data into other products for
// purposes authorized by the Autodesk software license agreement,
// without fee.
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the
// following disclaimer, must be included in all copies of the
// Software, in whole or in part, and all derivative works of
// the Software, unless such copies or derivative works are solely
// in the form of machine-executable object code generated by a
// source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
// AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
// PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR
// TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS LICENSORS
// BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK
// AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY
// OR PROBABILITY OF SUCH DAMAGES.
//
// ==========================================================================
//+

//	File Name: stereoCameraView.cpp
//
//	Description:
//		A class derived from MPx3dModelView to demonstrate some the render
//		of multiple cameras in a stereoscopic view.  Note, it is important 
//		that you have a graphics card capable of rendering to stereo 
//		buffers. 
//
//	Date: Sept 29, 2006. 
//

#include <stereoCameraParallelView.h>

#include <maya/MItDag.h>
#include <maya/MStringArray.h>
#include <maya/MGlobal.h>

#include <maya/MPoint.h>
#include <maya/MSelectionList.h>
#include <maya/MItSelectionList.h>
#include <maya/MIOStream.h>
#include <maya/MImage.h>

stereoCameraParallelView::stereoCameraParallelView() : 
	//fLeftBuffer( GL_BACK_LEFT ),
	//fRightBuffer( GL_FRONT_LEFT ),
	fValidView( true ),
	fOverrideHUDDraw( false ),
	fOverrideAdornmentDraw( false ),
	fSwapLeftRightEye( false ),
	fDrawFrameMask( false ),
	fDeviceRatio( 2.35 ),
	//mask
	fLeftLeftMask( 0 ),
	fLeftRightMask( 0 ),
	fRightLeftMask( 0 ),
	fRightRightMask( 0 ),
	//offset
	fLeftLeftOffset( 0 ),
	fLeftRightOffset( 0 ),
	fRightLeftOffset( 0 ),
	fRightRightOffset( 0 ),
	fEnableDiagnoseLine( false )
// 
// Description: 
//  Constructor. 
//
{
}

stereoCameraParallelView::~stereoCameraParallelView()
// 
// Description: 
//  Destructor. 
//
{
}

MString stereoCameraParallelView::getCameraHUDName()
//
// Description: 
// 
{
	MString hudName("stereoCameraParallelView: ");

	MDagPath cameraPath;
	getCamera(cameraPath);
	
	cameraPath.pop();
	hudName += cameraPath.partialPathName();
	
	//if ( fDisplayMode == kStereoAnaglyph ) { 
	//	hudName += " (stereo anaglyph)" ;
	if ( fDisplayMode == kStereoParallel ) { 
		hudName += " (stereo parallel)" ;
	} else if ( fDisplayMode == kLeftCamera ) { 
		hudName += " (left)";
	} else if ( fDisplayMode == kRightCamera ) { 
		hudName += " (right)"; 
	} else { 
		hudName += " (center)"; 
	}
	
	return hudName;
}

void stereoCameraParallelView::preMultipleDraw()
//
//  Description: 
//   Called before all draw passes.  
// 
{
	MDagPath oldCamera;
	MStatus status = getCamera(oldCamera);
	// Set the adornment drawing state ... 
	// 
	//setDrawAdornments( !fOverrideAdornmentDraw );

	// Disable HUD drawing ... 
	// 
	//setDisplayHUD( !fOverrideHUDDraw ); 

	if (MS::kSuccess != status) {
		status.perror("M3dView::getCamera");
	}
	
	if ( fCenterCamera.isValid() &&  fLeftCamera.isValid() && 
		 fRightCamera.isValid() ) {
		setCamera( fCenterCamera ); 
		fOldCamera = oldCamera;
		fValidView = true; 
	} else { 
		fValidView = false; 
	}

	//glEnable(GL_BLEND);
	//glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
	glEnable( GL_DEPTH_TEST ); 
	glDepthFunc( GL_LEQUAL );
	//glEnable(GL_LINE_SMOOTH);
    //glEnable(GL_POINT_SMOOTH);
	//glEnable(GL_POLYGON_SMOOTH);

	//glDrawBuffer(GL_BACK_LEFT);
	//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
    //glDrawBuffer(GL_BACK_RIGHT);
    //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	setDrawAdornments( true );
}


void stereoCameraParallelView::postMultipleDraw()
{
	if ( fValidView ) { 
		glDrawBuffer( GL_LEFT ); 
/*		if ( fDisplayMode != kStereoAnaglyph && fDisplayMode != kStereoParallel ) { 
			if ( fOverrideAdornmentDraw ) { 
				drawAdornmentsNow(); 
			}
			if ( fOverrideHUDDraw ) { 
				drawHUDNow(); 
			}
		}
*/

		// draw overlay frame mask


		//glDrawBuffer( GL_BACK_LEFT );
/*
		view.beginGL();
			glPushMatrix();
			glPushAttrib( GL_DEPTH_BUFFER_BIT );
			glDrawBuffer( GL_FRONT_LEFT );
			view.beginOverlayDrawing();
				view.clearOverlayPlane();
				glMatrixMode( GL_PROJECTION );
					glLoadIdentity();
					gluOrtho2D( 0.0, (GLdouble)portWidth(), 0, (GLdouble)portHeight() );
					glMatrixMode( GL_MODELVIEW );
						glLoadIdentity();
						//glDisable(GL_DEPTH_TEST);
						//glDisable(GL_CULL_FACE);
						//glDisable(GL_BLEND);
						//glDisable(GL_TEXTURE_2D);
						//glDisable(GL_LIGHTING);
						glBegin( GL_POLYGON );
						const GLfloat color[4] = {1,0,0,1};
						glColor4fv(color);
						glVertex2i( 100, 100 );
						glVertex2i( 50, 100 );
						glVertex2i( 50, 50 );
						glVertex2i( 100, 50 );
						glEnd();
						SwapBuffers( view.deviceContext() );
				view.clearOverlayPlane();
			view.endOverlayDrawing();

			glPopAttrib();
			glPopMatrix();
		view.endGL();
*/

		// draw frame mask
		if( fDrawFrameMask ){
			M3dView view;
			MStatus stat;
			stat = M3dView::getM3dViewFromModelPanel( "ccgScvScriptedPanel", view );
			if( !stat ) stat = M3dView::getM3dViewFromModelEditor( "ccgScvScriptedPanelEditor", view );

			if( stat ){
				float device_ratio = 1.0f/(float)fDeviceRatio;

				MImage image;
				bool readAsRGBA = false;
				if( view.readColorBuffer( image, readAsRGBA ) == MS::kSuccess ){
					unsigned char *pixelPtr = (unsigned char*) image.pixels();
					if(pixelPtr){
						unsigned int width, height;
						image.getSize( width, height );
						if( width>0 && height>0 ) {
							float viewRatio = (float)height/(float)width;
							float ratio = ( viewRatio - device_ratio)/2.0f / viewRatio;
							if( ratio<0 ) ratio = 0;

							MImage image2;
							image2.create( width, height );
							unsigned char *pixelPtr2 = (unsigned char*) image2.pixels();

							/*
								fLeftLeftMask is percentage of width of mask
								fllMask is the absolute position of the edge of mask
							*/
							unsigned int llMask, lrMask, rlMask, rrMask;
							int lwidth = flrMask - fllMask + 1;
							int rwidth = frrMask - frlMask + 1;
							if( !fSwapLeftRightEye ){
								llMask = floor(fLeftLeftMask*lwidth) + fllMask ;
								lrMask =  flrMask - floor(fLeftRightMask*lwidth) ;
								rlMask =  floor(fRightLeftMask*rwidth) + frlMask ;
								rrMask =  frrMask - floor(fRightRightMask*rwidth) ;
							} else {
								llMask = floor(fRightLeftMask*rwidth) + frlMask ;
								lrMask = frrMask - floor(fRightRightMask*rwidth) ;
								rlMask = floor(fLeftLeftMask*lwidth) + fllMask ;
								rrMask = flrMask - floor(fLeftRightMask*lwidth) ;
							}

							unsigned char white = 255;

							for( unsigned int i = 0; i<height; i++ ){
								for( unsigned int j=0; j<width; j++ ){
									if(fEnableDiagnoseLine){
										if(j==llMask || j==lrMask){
											pixelPtr2 ++; pixelPtr ++;
											pixelPtr2 ++; pixelPtr ++;
											//R
											*pixelPtr2 = white;
											pixelPtr2 ++; pixelPtr ++;
											pixelPtr2 ++; pixelPtr ++;
											continue;
										}else if(j==rlMask || j==rrMask){
											pixelPtr2 ++; pixelPtr ++;
											//G
											*pixelPtr2 = white;
											pixelPtr2 ++; pixelPtr ++;
											pixelPtr2 ++; pixelPtr ++;
											pixelPtr2 ++; pixelPtr ++;
											continue;
										}
									}
									float currentRatio = (float)(i+1)/(float)height;
									if( ((j>=llMask && j<=lrMask)||(j>=rlMask && j<=rrMask))
										&& currentRatio>=ratio && currentRatio<=(1-ratio) ){
										*pixelPtr2 = *pixelPtr;
										pixelPtr2 ++; pixelPtr ++;
										*pixelPtr2 = *pixelPtr;
										pixelPtr2 ++; pixelPtr ++;
										*pixelPtr2 = *pixelPtr;
										pixelPtr2 ++; pixelPtr ++;
										*pixelPtr2 = *pixelPtr;
										pixelPtr2 ++; pixelPtr ++;
									}else {
										pixelPtr2 += 4;
										pixelPtr += 4;
									}
								}
							}
							view.writeColorBuffer( image2 );
						}
					}
				}
			} //if M3dView exists
		}


		MStatus status = setCamera(fOldCamera);
		
		updateViewingParameters();
		if (MS::kSuccess != status) {
			status.perror("M3dView::setCamera");
		}
	}	// valid view
}

void stereoCameraParallelView::preMultipleDrawPass(unsigned currentPass)
//
//  Description: 
//   The main work routine. On each draw pass this routine specifies 
//   which buffer we should be drawing in.  
//
{
	MStatus status;
	MDagPath cameraToDraw;

	if ( !fValidView ) { 
		// We don't have valid cameras defined.
		return ; 
	}

	DisplayMode dm = displayMode(); 
	if ( /*dm == kStereoAnaglyph ||*/ dm == kStereoParallel ) { 
		if( currentPass==0 )
			cameraToDraw = fLeftCamera; 
		else cameraToDraw = fRightCamera;
	} else if ( dm == kLeftCamera ) { 
		cameraToDraw = fLeftCamera; 
	} else if ( dm == kRightCamera ) { 
		cameraToDraw = fRightCamera; 
	} else { 
		cameraToDraw = fCenterCamera;
	}
	
	if (MS::kSuccess != (status = setCameraInDraw(cameraToDraw))) {
		status.perror("M3dView::setCamera");
		return;
	}


	//	Turn on the display of everything, then selectively disable
	//	things.
	//
	//setObjectDisplay(M3dView::kDisplayEverything, true);

	glPushAttrib( GL_VIEWPORT_BIT );	// we gonna change viewport attribute

	// actually we override the default drawing buffers behavier
	// by default, we only need to set the current camera to be draw, then Maya API will draw automatically

	GLint cornerX, width;
	if( currentPass==0 ){
		if( dm==kStereoParallel ){
			if( !fSwapLeftRightEye ){
				GLint viewport[4];
				glGetIntegerv( GL_VIEWPORT, viewport );
					cornerX = viewport[0] + (int)fLeftLeftOffset;
					if( cornerX < 0 ) cornerX = 0;
					else if( cornerX > (viewport[2]-1) ) cornerX = viewport[2] - 1;
					width = (int)floor(viewport[2]/2.0) + (int)fLeftRightOffset - cornerX;
					if( width < 0 ) width = 0;
					else if( width > (viewport[2] - cornerX) ) width = viewport[2] - cornerX;
					fllMask = cornerX;
					flrMask = cornerX + width - 1;
				glViewport( cornerX, viewport[1], width, viewport[3]);
			}else {
				GLint viewport[4];
				glGetIntegerv( GL_VIEWPORT, viewport );
					cornerX = (int)ceil(viewport[2]/2.0) + (int)fLeftLeftOffset;
					if( cornerX < 0 ) cornerX = 0;
					else if( cornerX > (viewport[2]-1) ) cornerX = viewport[2] - 1;
					width = viewport[2] - cornerX + (int)fLeftRightOffset;
					if( width < 0 ) width = 0;
					else if( width > (viewport[2] - cornerX) ) width = viewport[2] - cornerX;
					fllMask = cornerX;
					flrMask = cornerX + width - 1;
				glViewport( cornerX, viewport[1], width, viewport[3]);
			}
		}/*else if( dm==kStereoAnaglyph ) {
			glColorMask(0,1,1,1);
			glClear( GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
			//glDisable( GL_DEPTH_TEST ); 
			//glDepthFunc( GL_LEQUAL );
		}*/
	}else {
			if( dm==kStereoParallel ){
				if( !fSwapLeftRightEye ){
					GLint viewport[4];
					glGetIntegerv( GL_VIEWPORT, viewport );
						cornerX = (int)ceil(viewport[2]/2.0) + (int)fRightLeftOffset;
						if( cornerX < 0 ) cornerX = 0;
						else if( cornerX > (viewport[2]-1) ) cornerX = viewport[2] - 1;
						width = viewport[2] - cornerX + (int)fRightRightOffset;
						if( width < 0 ) width = 0;
						else if( width > (viewport[2] - cornerX) ) width = viewport[2] - cornerX;
						frlMask = cornerX;
						frrMask = cornerX + width - 1;
					glViewport( cornerX, viewport[1], width, viewport[3]);
				}else {
					GLint viewport[4];
					glGetIntegerv( GL_VIEWPORT, viewport );
						cornerX = viewport[0] + (int)fRightLeftOffset;
						if( cornerX < 0 ) cornerX = 0;
						else if( cornerX > (viewport[2]-1) ) cornerX = viewport[2] - 1;
						width = (int)floor(viewport[2]/2.0) + (int)fRightRightOffset - cornerX;
						if( width < 0 ) width = 0;
						else if( width > (viewport[2] - cornerX) ) width = viewport[2] - cornerX;
						frlMask = cornerX;
						frrMask = cornerX + width - 1;
					glViewport( cornerX, viewport[1], width, viewport[3]);
				}
			}/*else if( dm==kStereoAnaglyph ) {
				glColorMask(1,0,0,1);
				glClear( GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
				//glDisable( GL_DEPTH_TEST );
			}*/
		}

	//setLightingMode(kLightDefault);
	updateViewingParameters();
}

void stereoCameraParallelView::postMultipleDrawPass(unsigned index)
{
	//	Until better control over selection and picking is exposed,
	//	turn on the display of everything after drawing. The selection
	//	methods will not consider things that are not visible.

	/*DisplayMode dm = displayMode(); 
	if ( dm == kStereoAnaglyph ) { 
		glColorMask(1,1,1,1);
		glClear( GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
	}*/

	//setObjectDisplay(M3dView::kDisplayEverything, true);
	//if ( /*fDisplayMode == kStereoAnaglyph ||*/ fDisplayMode == kStereoParallel ) { 
	//	if ( fOverrideAdornmentDraw ) { 
	//		drawAdornmentsNow(); 
	//	}
	//	if ( fOverrideHUDDraw ) { 
	//		drawHUDNow(); 
	//	}
	//}

	glPopAttrib();	// restore viewport attribute stack
}

bool stereoCameraParallelView::okForMultipleDraw(const MDagPath &dagPath)
//
// Description: 
//  This routine is responsible excluding objects from the draw pass. 
//  In this case, we do not want to draw stereo cameras.  By default 
//  MPx3dModelView class excludes the main camera set in setCamera. 
//  However, it will not exclude the left & right camera because it 
//  has no idea that they are a part of the view. 
//
{
	if ( dagPath == fCenterCamera || 
		 dagPath == fRightCamera ||  
		 dagPath == fLeftCamera ) { 
		return false; 
	}
	return true;
}

unsigned stereoCameraParallelView::multipleDrawPassCount()
//
// Description: 
//  Tells the draw pass engine how many passes we want to draw.  For 
//  stereoscopic. This value should always be two (one for each buffer). 
//  
{
	// Some graphics cards do not support stereo buffers. We need to check the
	// stereo bit to see if we were successfully able to get a stereo buffer. 
	// If we failed to allocate a stereo buffer then we only draw one pass. This 
	// method is called before draw passes. 
	// 
	//if ( hasStereoBufferSupport() ) { 
	//	return 2; 
	//}

	DisplayMode dm = displayMode(); 
	//if ( dm == kStereoAnaglyph || dm == kStereoParallel ) return 2;
	if ( dm == kStereoParallel ) return 2;
	return 1;
}

void * stereoCameraParallelView::creator()
{
	return new stereoCameraParallelView();
}

MString stereoCameraParallelView::viewType() const
//
//	Description:
//    A string object that _uniquely_ represents this view.  You should
//    make sure this value is unique across all views. 
//
{
	return MString("stereoCameraParallelView");
}

/*
bool stereoCameraView::wantStereoGLBuffer() const 
// 
// Description: 
//  This tells the base model view classes to construct a view that 
//  is stereoscopic capable. If the card supports stereo graphics, 
//  then the you will have access to quad buffers left front/back & 
//  right front/back.  If the card does not support stereo graphics, 
//  then a normal double buffer view will be created. 
//
{
	return true;
}*/

void stereoCameraParallelView::setLeftCamera( MDagPath &camera )
//
// Description: 
//  Specifies the left camera. The dag path must point to
//  a cameraShape (not transform). 
// 
{
	fLeftCamera = camera; 
	updateViewingParameters(); 
	refresh(); 
}

MDagPath stereoCameraParallelView::leftCamera( ) const
// 
// Description: 
//  Returns the left camera. 
//
{
	return fLeftCamera; 
}

void stereoCameraParallelView::setRightCamera( MDagPath &camera )
// 
// Description: 
//  Sets ths right camera. The dag path must point to a 
//  cameraShape (not transform). 
// 
{
	fRightCamera = camera; 
	updateViewingParameters(); 
	refresh(); 
}
	
MDagPath stereoCameraParallelView::rightCamera( ) const
// 
// Description: 
//  Returns the current right camera. 
// 
{
	return fRightCamera; 
}

void stereoCameraParallelView::setCenterCamera( MDagPath &camera )
//
// Description: 
//  Sets the camera that should be in the middle. Dag path must 
//  point to a cameraShape (not transform). 
//
{
	fCenterCamera = camera; 
	updateViewingParameters(); 
	refresh();
}

MDagPath stereoCameraParallelView::centerCamera( ) const
{
	return fCenterCamera;
}
	
void stereoCameraParallelView::setDisplayMode( stereoCameraParallelView::DisplayMode dm )
// 
// Description:
//   Specifies the display mode. 
//
{
	fDisplayMode = dm; 
	// We need to force a refresh to catch all cases.  The low level view classes
	// are not aware that we are drawing for three different cameras and we must
	// force a refresh when we switch our view. 
	// 
	refresh( false, true );
}

stereoCameraParallelView::DisplayMode stereoCameraParallelView::displayMode( ) const
//
// Description: 
//  Return the current display mode as an enum. 
//
{
	return fDisplayMode; 
}

/*
void stereoCameraView::swapLeftRightBuffer()
//
// Description: 
//  Swap the buffer that is used for left camera with the buffer 
//  for the right camera.  Likewise for the right camera.  
//
{
	GLenum tBuffer = fLeftBuffer; 
	fLeftBuffer = fRightBuffer;
	fRightBuffer = tBuffer; 
	refresh();
}
*/

void stereoCameraParallelView::setSwapLeftRightEye( bool v )
{
	fSwapLeftRightEye = v;
	refresh();
}

bool stereoCameraParallelView::swapLeftRightEye() const
{
	return fSwapLeftRightEye;
}

void stereoCameraParallelView::setOverrideHUDDraw( bool v )
{
	fOverrideHUDDraw = v; 
	refresh(); 
}
bool stereoCameraParallelView::overrideHUDDraw() const
{
	return fOverrideHUDDraw; 
}

void stereoCameraParallelView::setOverrideAdornmentDraw( bool v )
{
	fOverrideAdornmentDraw = v ;
	refresh(); 
}

bool stereoCameraParallelView::overrideAdornmentDraw( ) const
{
	return fOverrideAdornmentDraw;
}

void stereoCameraParallelView::setDrawFrameMask( bool v )
{
	fDrawFrameMask = v;
	refresh();
}
bool stereoCameraParallelView::drawFrameMask() const
{
	return fDrawFrameMask;
}

void stereoCameraParallelView::setDeviceRatio( double d )
{
	fDeviceRatio = d;
	refresh();
}
double stereoCameraParallelView::deviceRatio() const
{
	return fDeviceRatio;
}

//mask
void stereoCameraParallelView::setLeftLeftMask( double d )
{
	if( d>0 ) fLeftLeftMask = d;
	else fLeftLeftMask = 0;
	refresh();
}
double stereoCameraParallelView::leftLeftMask() const
{
	return fLeftLeftMask;
}

void stereoCameraParallelView::setLeftRightMask( double d )
{
	if( d>0 ) fLeftRightMask = d;
	else fLeftRightMask = 0;
	refresh();
}
double stereoCameraParallelView::leftRightMask() const
{
	return fLeftRightMask;
}

void stereoCameraParallelView::setRightLeftMask( double d )
{
	if( d>0 ) fRightLeftMask = d;
	else fRightLeftMask = 0;
	refresh();
}
double stereoCameraParallelView::rightLeftMask() const
{
	return fRightLeftMask;
}

void stereoCameraParallelView::setRightRightMask( double d )
{
	if( d>0 ) fRightRightMask = d;
	else fRightRightMask = 0;
	refresh();
}
double stereoCameraParallelView::rightRightMask() const
{
	return fRightRightMask;
}

//offset
void stereoCameraParallelView::setLeftLeftOffset( double d )
{
	fLeftLeftOffset = d;
	refresh();
}
double stereoCameraParallelView::leftLeftOffset() const
{
	return fLeftLeftOffset;
}

void stereoCameraParallelView::setLeftRightOffset( double d )
{
	fLeftRightOffset = d;
	refresh();
}
double stereoCameraParallelView::leftRightOffset() const
{
	return fLeftRightOffset;
}

void stereoCameraParallelView::setRightLeftOffset( double d )
{
	fRightLeftOffset = d;
	refresh();
}
double stereoCameraParallelView::rightLeftOffset() const
{
	return fRightLeftOffset;
}

void stereoCameraParallelView::setRightRightOffset( double d )
{
	fRightRightOffset = d;
	refresh();
}
double stereoCameraParallelView::rightRightOffset() const
{
	return fRightRightOffset;
}

void stereoCameraParallelView::setEnableDiagnoseLine( bool v )
{
	fEnableDiagnoseLine = v;
	refresh();
}
bool stereoCameraParallelView::enableDiagnoseLine() const
{
	return fEnableDiagnoseLine;
}

const char*  stereoCameraParallelView::className() 
// 
// Description: 
//  Used for debugging only. See errorMacros.h 
//
{
	return "stereoCameraParallelView"; 
}
