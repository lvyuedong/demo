//-
// ==========================================================================
// Copyright (C) 1995 - 2006 Autodesk, Inc. and/or its licensors.  All
// rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its
// licensors, which is protected by U.S. and Canadian federal copyright
// law and by international treaties.
//
// The Data is provided for use exclusively by You. You have the right
// to use, modify, and incorporate this Data into other products for
// purposes authorized by the Autodesk software license agreement,
// without fee.
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the
// following disclaimer, must be included in all copies of the
// Software, in whole or in part, and all derivative works of
// the Software, unless such copies or derivative works are solely
// in the form of machine-executable object code generated by a
// source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
// AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
// PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR
// TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS LICENSORS
// BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK
// AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY
// OR PROBABILITY OF SUCH DAMAGES.
//
// ==========================================================================
//+

//	File Name: stereoCameraViewCmd.cpp
//
//	Description:
//    Demonstrates how to setup a MPx3dModelView with stereoscopic support.
//    You graphics card must support stereo buffers.
//
//    This is the main command for creating MPx3dModelViews. This commands
//    only acts as an interface to the actual viewport. It is derived 
//    off of MPxModelEditorCommand. 
//
//	Date:	Oct 2 2006
//

#include <stereoCameraParallelViewCmd.h>

#include <maya/MItDag.h>
#include <maya/MGlobal.h>
#include <maya/MSyntax.h>
#include <maya/MArgParser.h>
#include <maya/MArgList.h>
#include <maya/MSelectionList.h>
#include <maya/MFnCamera.h>

#include <maya/MIOStream.h> 

stereoCameraParallelViewCmd::stereoCameraParallelViewCmd()
: 	MPxModelEditorCommand()
//
//	Description:
//		Class constructor.
//
{
}

stereoCameraParallelViewCmd::~stereoCameraParallelViewCmd()
//
//	Description:
//		Class destructor.
//
{
}

void* stereoCameraParallelViewCmd::creator()
//
//	Description:
//		Creator function for this command. 
//
{
    return new stereoCameraParallelViewCmd();
}

MPx3dModelView *stereoCameraParallelViewCmd::userView()
//
//	Description:
//      Creator funcation for the panel view.  This is the 3dGraphics view. 
//
{
    return new stereoCameraParallelView();
}

MStatus stereoCameraParallelViewCmd::appendSyntax()
//
//	Description:
//		Add syntax to the command. All of the parent syntax is added
//		before this call is made. Be careful not to add flags that already
//		exist in the base class (see modelEditor command for more information).
//
{
	MStatus ReturnStatus;

	MSyntax theSyntax = syntax(&ReturnStatus);
	if (MS::kSuccess != ReturnStatus) {
		MGlobal::displayError("Could not get the parent's syntax");
		return ReturnStatus;
	}

	theSyntax.addFlag( kLeftEyeCameraFlag, kLeftEyeCameraFlagLong, 
					   MSyntax::kString );
	theSyntax.addFlag( kRightEyeCameraFlag, kRightEyeCameraFlagLong, 
					   MSyntax::kString ); 
	theSyntax.addFlag( kCenterCameraFlag, kCenterCameraFlagLong, 
					   MSyntax::kString );
	theSyntax.addFlag( kDisplayModeFlag, kDisplayModeFlagLong, 
					   MSyntax::kString ); 
	//theSyntax.addFlag( kSwapBufferFlag, kSwapBufferFlagLong );

	theSyntax.addFlag( kOverrideAdornmentDrawFlag, 
					   kOverrideAdornmentDrawFlagLong, 
					   MSyntax::kBoolean  ); 

	theSyntax.addFlag( kOverrideHUDDrawFlag, 
					   kOverrideHUDDrawFlagLong, 
					   MSyntax::kBoolean );

	theSyntax.addFlag( kSwapLeftRightEyeFlag,
						kSwapLeftRightEyeFlagLong,
						MSyntax::kBoolean );

	theSyntax.addFlag( kDrawFrameMaskFlag,
						kDrawFrameMaskFlagLong,
						MSyntax::kBoolean );
	theSyntax.addFlag( kDeviceRatioFlag,
						kDeviceRatioFlagLong,
						MSyntax::kDouble );

	theSyntax.addFlag( kLeftLeftMaskFlag, kLeftLeftMaskFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kLeftRightMaskFlag, kLeftRightMaskFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kRightLeftMaskFlag, kRightLeftMaskFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kRightRightMaskFlag, kRightRightMaskFlagLong, MSyntax::kDouble );

	theSyntax.addFlag( kLeftLeftOffsetFlag, kLeftLeftOffsetFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kLeftRightOffsetFlag, kLeftRightOffsetFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kRightLeftOffsetFlag, kRightLeftOffsetFlagLong, MSyntax::kDouble );
	theSyntax.addFlag( kRightRightOffsetFlag, kRightRightOffsetFlagLong, MSyntax::kDouble );

	theSyntax.addFlag( kEnableDiagnoseLineFlag, kEnableDiagnoseLineFlagLong, MSyntax::kBoolean );
	
	return ReturnStatus;
}

MStatus stereoCameraParallelViewCmd::doEditFlags()
//
//	Description:
//		Handle edits for flags added by this class.  If the flag is
//		known, return MS::kSuccess after processing the flag.
//		Returning MS::kUnknownParameter will cause the parent class to
//		process the flag.
//
{
	MStatus ReturnStatus = MS::kSuccess;

	MPx3dModelView *user3dModelView = modelView();
	if (NULL == user3dModelView ||
		user3dModelView->viewType() != "stereoCameraParallelView") {
		MGlobal::displayError("Not a stereo camera parallel view!");
		// Depending on your class structure, will dictate how you 
		// handle this case. If you have additional classes derived
		// from MPx3dModelViewCommand you should always call the
		// parent class doEditFlags to allow base classes to handle
		// any flags.  In this case, returning MS::kUnknownParameter 
		// tells the API that it should call the parent class.  
		//
		return MS::kUnknownParameter;
	}

	// This is now safe to do, since the above test passed. It is very
	// important that you have an unique string describing your custom
	// view. If you do not have a unique name, then it is impossible
	// to know when you are dealing with the proper view.
	//
	stereoCameraParallelView *mpView = (stereoCameraParallelView *)user3dModelView;

	MArgParser argData = parser();
	if ( argData.isFlagSet(kDisplayModeFlag) ) {
		// Check the display mode. This will dictate how stereo data
		// is rendered in the view port. 
		//    
		MString displayMode; 
		argData.getFlagArgument( kDisplayModeFlag, 0, displayMode );
		//if ( displayMode == kStereoAnaglyphMode ) { 
		//	mpView->setDisplayMode( stereoCameraView::kStereoAnaglyph ); 
		if ( displayMode == kStereoParallelMode ) {
			mpView->setDisplayMode( stereoCameraParallelView::kStereoParallel ); 
		} else if ( displayMode == kLeftEye ) { 
			mpView->setDisplayMode( stereoCameraParallelView::kLeftCamera );
		} else if ( displayMode == kRightEye ) { 
			mpView->setDisplayMode( stereoCameraParallelView::kRightCamera ); 
		} else if ( displayMode == kCenterEye ) { 
			mpView->setDisplayMode( stereoCameraParallelView::kCenterCamera );
		} else { 
			MGlobal::displayError( "Invalid display mode" ); 
			return MS::kFailure; 
		}
	}


	// The next set of flags check for changes to the camera settings.
	// We need the user to specify the left, right, and center camera.
	// The center camera is useful for viewing the scene when stereo
	// is "off".  Note, stereo is never really off. We are simplying
	// drawing the same buffer into the left & right image to give the
	// appearance of no stereo. 
	//  
	// Currently there is not a lot of checking to verify that the 
	// camera you specified is actually valid.  If an invalid camera
	// is specified then it is possible that Maya will crash.  This
	// is left as an exercise to the reader :-). 
	//
	if ( argData.isFlagSet(kLeftEyeCameraFlag) ) {
		// Assign the camera for the left eye
		// 
		MString camera; 
		argData.getFlagArgument( kLeftEyeCameraFlag, 0, camera );
		MDagPath theCamera; 
		MStatus status = getCameraFromString( camera, theCamera );
		if ( status == MS::kFailure ) { 
			return status; 
		}
		mpView->setLeftCamera( theCamera );
	} 
	if ( argData.isFlagSet(kRightEyeCameraFlag) ) {
		// Assign the camera for the right eye 
		//
		MString camera; 
		argData.getFlagArgument( kRightEyeCameraFlag, 0, camera );
		MDagPath theCamera; 
		MStatus status = getCameraFromString( camera, theCamera );
		if ( status == MS::kFailure ) { 
			return status; 
		}
		mpView->setRightCamera( theCamera );		
	} 
	if ( argData.isFlagSet(kCenterCameraFlag) ) {
		// Assign the center camera.  This camera represents the 
		// left & right camera when not in 3d view. 
		//
		MString camera; 
		argData.getFlagArgument( kCenterCameraFlag, 0, camera );
		MDagPath theCamera; 
		MStatus status = getCameraFromString( camera, theCamera );
		if ( status == MS::kFailure ) { 
			return status; 
		}
		mpView->setCenterCamera( theCamera );		
		mpView->setCamera( theCamera ); 
	}
	//if ( argData.isFlagSet( kSwapBufferFlag ) ) { 
	//	mpView->swapLeftRightBuffer(); 
	//}
	if( argData.isFlagSet( kSwapLeftRightEyeFlag ) ){
		bool overrideV;
		argData.getFlagArgument( kSwapLeftRightEyeFlag, 0, overrideV );
		mpView->setSwapLeftRightEye( overrideV );
	}
	if ( argData.isFlagSet( kOverrideAdornmentDrawFlag ) ) { 
		bool overrideV; 
		argData.getFlagArgument( kOverrideAdornmentDrawFlag, 0, overrideV ); 
		mpView->setOverrideAdornmentDraw( overrideV ); 
	}
	if ( argData.isFlagSet( kOverrideHUDDrawFlag ) ) { 
		bool overrideV; 
		argData.getFlagArgument( kOverrideHUDDrawFlag, 0, overrideV ); 
		mpView->setOverrideHUDDraw( overrideV ); 
	}

	if( argData.isFlagSet( kDrawFrameMaskFlag ) ){
		bool overrideV;
		argData.getFlagArgument( kDrawFrameMaskFlag, 0, overrideV );
		mpView->setDrawFrameMask( overrideV );
	}

	if( argData.isFlagSet( kDeviceRatioFlag ) ){
		double overrideD;
		argData.getFlagArgument( kDeviceRatioFlag, 0, overrideD );
		mpView->setDeviceRatio( overrideD );
	}

	//mask
	if( argData.isFlagSet( kLeftLeftMaskFlag ) ){
		double overrideD;
		argData.getFlagArgument( kLeftLeftMaskFlag, 0, overrideD );
		mpView->setLeftLeftMask( overrideD );
	}

	if( argData.isFlagSet( kLeftRightMaskFlag ) ){
		double overrideD;
		argData.getFlagArgument( kLeftRightMaskFlag, 0, overrideD );
		mpView->setLeftRightMask( overrideD );
	}

	if( argData.isFlagSet( kRightLeftMaskFlag ) ){
		double overrideD;
		argData.getFlagArgument( kRightLeftMaskFlag, 0, overrideD );
		mpView->setRightLeftMask( overrideD );
	}

	if( argData.isFlagSet( kRightRightMaskFlag ) ){
		double overrideD;
		argData.getFlagArgument( kRightRightMaskFlag, 0, overrideD );
		mpView->setRightRightMask( overrideD );
	}

	//offset
	if( argData.isFlagSet( kLeftLeftOffsetFlag ) ){
		double overrideD;
		argData.getFlagArgument( kLeftLeftOffsetFlag, 0, overrideD );
		mpView->setLeftLeftOffset( overrideD );
	}

	if( argData.isFlagSet( kLeftRightOffsetFlag ) ){
		double overrideD;
		argData.getFlagArgument( kLeftRightOffsetFlag, 0, overrideD );
		mpView->setLeftRightOffset( overrideD );
	}

	if( argData.isFlagSet( kRightLeftOffsetFlag ) ){
		double overrideD;
		argData.getFlagArgument( kRightLeftOffsetFlag, 0, overrideD );
		mpView->setRightLeftOffset( overrideD );
	}

	if( argData.isFlagSet( kRightRightOffsetFlag ) ){
		double overrideD;
		argData.getFlagArgument( kRightRightOffsetFlag, 0, overrideD );
		mpView->setRightRightOffset( overrideD );
	}

	if( argData.isFlagSet( kEnableDiagnoseLineFlag ) ){
		bool overrideV;
		argData.getFlagArgument( kEnableDiagnoseLineFlag, 0, overrideV );
		mpView->setEnableDiagnoseLine( overrideV );
	}

	// Ask the parent class to process its flags. 
	//
	return ParentClass::doEditFlags();
}

MStatus stereoCameraParallelViewCmd::doQueryFlags()
//
//	Description:
//		Don't do anything for the query.
//
{
	MPx3dModelView *user3dModelView = modelView();
	if (NULL == user3dModelView) {
		MGlobal::displayError("NULL == user3dModelView!");
        // Depending on your class structure, will dictate how you 
        // handle this case. If you have additional classes derived
        // from MPx3dModelViewCommand you should always call the
        // parent class doQueryFlags to allow base classes to handle
        // any flags.  In this case, returning MS::kUnknownParameter
        // tells the API that it should call the parent class.
        //
        return MS::kUnknownParameter;
	}

	if (user3dModelView->viewType() != "stereoCameraParallelView") {
		MGlobal::displayError("This view is not a multiPackTest parallel view");
		return MS::kFailure;
	}

	//	This is now safe to do, since the above test passed.
	//
	stereoCameraParallelView *mpView = (stereoCameraParallelView *)user3dModelView;
	
	MArgParser argData = parser();
	if ( argData.isFlagSet(kDisplayModeFlag) ) {
		stereoCameraParallelView::DisplayMode mode = mpView->displayMode(); 
		switch (mode) { 
		case stereoCameraParallelView::kLeftCamera: 
			setResult( MString(kLeftEye) ); 
			break; 
		case stereoCameraParallelView::kRightCamera:
			setResult( MString(kRightEye) ); 
			break; 
		case stereoCameraParallelView::kCenterCamera:
			setResult( MString(kCenterEye) );
			break; 
		//case stereoCameraView::kStereoAnaglyph:
		//	setResult( MString(kStereoAnaglyphMode) ); 
		//	break; 
		case stereoCameraParallelView::kStereoParallel:
			setResult( MString(kStereoParallelMode) );
			break;
		default: 
			MGlobal::displayError( "Internal error: unrecognized mode!" ); 
		};
		return MS::kSuccess; 
	}

	// If the user asks for it, return the currently defined left, right,
	// or center cameras. 
	//
	if ( argData.isFlagSet(kLeftEyeCameraFlag) ) {
		MDagPath camera = mpView->leftCamera(); 
		setResult( camera.partialPathName() ); 
		return MS::kSuccess; 
	} 
	if ( argData.isFlagSet(kRightEyeCameraFlag) ) {
		MDagPath camera = mpView->rightCamera();
		setResult( camera.partialPathName() ); 
		return MS::kSuccess; 
	} 
	if ( argData.isFlagSet(kCenterCameraFlag) ) { 
		MDagPath camera = mpView->centerCamera(); 		
		setResult( camera.partialPathName() );		
		return MS::kSuccess; 
	}

	// Override draw settings ... 
	//
	if ( argData.isFlagSet(kOverrideAdornmentDrawFlag) ) { 
		setResult( mpView->overrideAdornmentDraw() );
		return MS::kSuccess; 
	}
	if ( argData.isFlagSet(kOverrideHUDDrawFlag) ) { 
		setResult( mpView->overrideHUDDraw() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet(kSwapLeftRightEyeFlag) ) {
		setResult( mpView->swapLeftRightEye() );
		return MS::kSuccess;
	}

	if( argData.isFlagSet( kDrawFrameMaskFlag ) ){
		setResult( mpView->drawFrameMask() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kDeviceRatioFlag ) ){
		setResult( mpView->deviceRatio() );
		return MS::kSuccess;
	}

	//mask
	if( argData.isFlagSet( kLeftLeftMaskFlag ) ){
		setResult( mpView->leftLeftMask() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kLeftRightMaskFlag ) ){
		setResult( mpView->leftRightMask() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kRightLeftMaskFlag ) ){
		setResult( mpView->rightLeftMask() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kRightRightMaskFlag ) ){
		setResult( mpView->rightRightMask() );
		return MS::kSuccess;
	}

	//offset
	if( argData.isFlagSet( kLeftLeftOffsetFlag ) ){
		setResult( mpView->leftLeftOffset() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kLeftRightOffsetFlag ) ){
		setResult( mpView->leftRightOffset() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kRightLeftOffsetFlag ) ){
		setResult( mpView->rightLeftOffset() );
		return MS::kSuccess;
	}
	if( argData.isFlagSet( kRightRightOffsetFlag ) ){
		setResult( mpView->rightRightOffset() );
		return MS::kSuccess;
	}

	if( argData.isFlagSet( kEnableDiagnoseLineFlag ) ){
		setResult( mpView->enableDiagnoseLine() );
		return MS::kSuccess;
	}
	
	return ParentClass::doQueryFlags();
}

MString stereoCameraParallelViewCmd::editorMenuScriptName() const
//
//  Description:
//   This script is called to setup menus. 
//
{
	return MString(kStereoCameraParallelMenuScript);
}

MStatus stereoCameraParallelViewCmd::getCameraFromString( 
	const MString &cameraName, MDagPath &cameraPath ) 
// 
// Description: 
//  Helper function that can take a camera name and return the corresponding
//  dag path. 
// 
{
	MSelectionList slist; 
	MStatus status = slist.add( cameraName );
	if ( status == MS::kSuccess ) { 
		status = slist.getDagPath( 0, cameraPath );
		if ( status == MS::kSuccess ) { 
			cameraPath.extendToShape(); 
			return status; 
		}
	}

	MGlobal::displayError( "Invalid camera name: " + cameraName ); 
	return status; 
}

const char * stereoCameraParallelViewCmd::className()
{
	return "stereoCameraParallelViewCmd";
}
